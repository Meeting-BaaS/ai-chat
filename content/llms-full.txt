file: ./content/docs/api/community-and-support.mdx
# MeetingBaas API, the main purpose of the documentation: Community & Support

Join our Discord Community, or ping us on our socials.
        
## Community:

* [Join our Discord](https://discord.com/invite/dsvFgDTr6c)
* [Star us on Github](https://github.com/Meeting-Baas/Meeting-Bot-As-A-Service)

## Contact & Support

Planning to use more than 100 hours a month?\
Expect a response within the day.

* Twitter
* <ContactLink />
* Slack and Teams channels for customers and partners.


file: ./content/docs/api/index.mdx
# MeetingBaas API, the main purpose of the documentation: Introduction

Deploy AI for video meetings through a single unified API.
        
**Meeting BaaS** üêü provides *Meetings Bots As A Service*, with integrated transcription.

This allows you to:

1. **interact with**
2. **transcribe**
3. **AI summarize**

video-meetings through a single unified API. Using Meeting BaaS, you can deploy bots on Microsoft Teams, Google Meet, and Zoom in less than 1 minute.

Our meeting bots act as regular meeting participants with full audio and visual capabilities.

They can listen, speak, use chat, and appear with customizable names and profile pictures.

Just provide a meeting URL through a simple command, and meeting bots will connect to the meeting, give their name and ask to be let in.

Once inside, they record the meeting until it ends, and provide you with the data as they go.


file: ./content/docs/speaking-bots/acknowledgements.mdx
# Speaking Bots, the Pipecat-powered bots: Acknowledgements

Core services powering the speaking bot
        
[Pipecat](https://github.com/pipecat-ai/pipecat) and [MeetingBaas](https://meetingbaas.com) both do the heavy lifting of powering the speaking bot - but the project requires many other core services to function.

As you can see in the technologies used below, speaking bots can connect to external services for pinging weather data or timezone information.

<Accordions>
  <Accordion title="Core Services">
    * [Pipecat](https://github.com/pipecat-ai/pipecat):
      Python framework powering real-time audio processing pipeline

    * [MeetingBaas](https://meetingbaas.com):
      Meeting bot deployment API for Google Meet, Microsoft Teams, and Zoom

    * [Ngrok](https://ngrok.com):
      Local development tunneling for WebSocket connections
  </Accordion>

  {" "}

  <Accordion title="Speech Services">
    * [Cartesia](https://cartesia.ai):
      Text-to-speech service for bot voice synthesis

    * [Deepgram](https://deepgram.com):
      Primary speech-to-text service for real-time transcription

    * [Gladia](https://gladia.io):
      Alternative speech-to-text provider with language recognition
  </Accordion>

  {" "}

  <Accordion title="AI & Language Models">
    * [OpenAI](https://openai.com): GPT models for conversation generation

    * [Silero VAD](https://github.com/snakers4/silero-vad): Voice activity
      detection
  </Accordion>

  {" "}

  <Accordion title="Development Tools">
    * [Protocol Buffers](https://protobuf.dev): Data serialization for WebSocket
      communication

    * [Poetry](https://python-poetry.org): Python dependency management

    * [Loguru](https://github.com/Delgan/loguru): Structured logging
  </Accordion>

  <Accordion title="Additional Services">
    * [wttr.in](https://wttr.in):
      Weather data API

    * [pytz](https://pythonhosted.org/pytz):
      Timezone database
  </Accordion>
</Accordions>


file: ./content/docs/speaking-bots/command-line.mdx
# Speaking Bots, the Pipecat-powered bots: Command line usage

Complete command-line interface options for launching Speaking Bots
        
## Basic Usage

```bash
poetry run python scripts/batch.py [options]
```

## Core Options

| Option             | Description                      | Required | Default | Example                                              |
| ------------------ | -------------------------------- | -------- | ------- | ---------------------------------------------------- |
| `-c, --count`      | Number of bot instances          | Yes      | -       | `-c 2`                                               |
| `--meeting-url`    | Video meeting URL to join        | Yes      | -       | `--meeting-url https://meet.google.com/xxx-yyyy-zzz` |
| `--personas`       | Space-separated list of personas | No       | Random  | `--personas baas_onboarder arctic_prospector`        |
| `-s, --start-port` | Starting port for services       | No       | 8765    | `--start-port 8765`                                  |
| `--add-recorder`   | Add recording-only bot           | No       | False   | `--add-recorder`                                     |

## Example Commands

### Basic Bot Launch

```bash
poetry run python scripts/batch.py -c 1 --meeting-url LINK
```

### Multiple Bots with Specific Personas

```bash
poetry run python scripts/batch.py -c 2 --meeting-url LINK --personas baas_onboarder arctic_prospector
```

### Additional "passive" bot with recording

```bash
poetry run python scripts/batch.py -c 1 --meeting-url LINK --add-recorder
```

## Technical Details

### Port Allocation

* Each bot requires 2 consecutive ports:
  * Bot process: port N
  * Proxy process: port N+1
* Default starting port: 8765
* Example with 2 bots:
  * Bot 1: 8765 (bot), 8766 (proxy)
  * Bot 2: 8767 (bot), 8768 (proxy)

### Persona Selection

* If specific personas provided: uses them in order
* If not enough personas specified: fills with random selections
* Validates persona existence before launch
* Avoids duplicate personas when possible
* Logs selected persona names and prompts

### Interactive Controls

* Press Enter: Add more bots with same configuration. You might be blocked by the default deduplication key settings.
* Ctrl+C: Graceful shutdown of all processes

### Error Handling

* URL validation (must start with https\://)
* Port availability checking
* Process monitoring and auto-recovery
* Ngrok tunnel management
* Graceful resource cleanup

### Process Management

* Automatic ngrok tunnel creation
* Process output logging
* Auto-cleanup on shutdown
* Graceful termination of all components


file: ./content/docs/speaking-bots/index.mdx
# Speaking Bots, the Pipecat-powered bots: Introduction

Deploy AI-powered speaking agents in video meetings
        
This repository demonstrates the capabilities of [MeetingBaas](https://meetingbaas.com) üêü's video meeting APIs by integrating with [Pipecat](https://github.com/pipecat-ai/pipecat)'s Python framework for building voice and multimodal conversational agents.

Our implementation creates AI meeting agents that can join and participate in Google Meet and Microsoft Teams meetings with distinct personalities and context defined in Markdown files.

This implementation extends Pipecat's [WebSocket server implementation](https://github.com/pipecat-ai/pipecat/tree/main/examples/websocket-server) to create:

* Meeting agents that can join Google Meet, Zoom or Microsoft Teams through the [MeetingBaas API](https://meetingbaas.com)
* Customizable personas with unique context
* Support for running multiple instances locally or at scale

<Card icon={<Github />} title="Speaking Meeting Bot" href="https://github.com/Meeting-Baas/speaking-meeting-bot" description="Clone and star our repository to launch and scale AI-powered meeting agents" external />

## Directory Structure

<Files>
  <Folder name="config" description="Core configuration and persona management">
    <Folder name="personas" description="Persona definitions and behaviors">
      <Folder name="baas_onboarder" description="MeetingBaas API presentation persona">
        <File name="README.md" description="Core persona definition and behavior" />

        <File name="Content.md" description="Knowledge and contextual information" />

        <File name="Rules.md" description="Interaction and behavior guidelines" />
      </Folder>

      <Folder name="noota_assistant" description="Noota software sales persona" />

      <Folder name="gladia_sales" description="Gladia API sales persona" />
    </Folder>

    <File name="persona_types.py" description="Data structures and type definitions for personas" />

    <File name="persona_utils.py" description="Persona management and utility functions" />

    <File name="prompts.py" description="Default prompts and system messages" />

    <File name="create_persona.py" description="Tools for creating new personas" />

    <File name="migrate_personas.py" description="Migration utilities for persona updates" />
  </Folder>

  <Folder name="meetingbaas_pipecat" description="Core bot functionality and communications">
    <Folder name="bot" description="Bot implementation and behavior">
      <File name="bot.py" description="Main bot class and meeting interactions" />

      <File name="runner.py" description="Bot execution and lifecycle management" />

      <File name="__init__.py" />
    </Folder>

    <Folder name="proxy" description="Proxy handling for multiple bot instances" />

    <Folder name="utils" description="Shared utilities">
      <File name="logger.py" description="Logging configuration" />

      <File name="__init__.py" />
    </Folder>

    <File name="__init__.py" />
  </Folder>

  <Folder name="scripts" description="Command-line tools and utilities">
    <File name="meetingbaas.py" description="MeetingBaas API interaction script" />

    <File name="batch.py" description="Multiple bot deployment script" />
  </Folder>
</Files>


file: ./content/docs/speaking-bots/personas.mdx
# Speaking Bots, the Pipecat-powered bots: Personas System

AI meeting participants with distinct personalities
        
The personas system enables AI-powered meeting participants with distinct personalities and behaviors for video meetings through the Meeting BaaS API and the Pipecat framework.

## Directory Structure

<Files>
  <Folder name="config" description="Root configuration directory" defaultOpen>
    <Folder name="personas" description="Directory containing all persona definitions" defaultOpen>
      <Folder name="baas_onboarder" description="Example persona implementation" defaultOpen>
        <File name="README.md" description="Core persona definition and behavior" />

        <File name="Content.md" description="Knowledge and contextual information" />

        <File name="Rules.md" description="Interaction and behavior guidelines" />
      </Folder>
    </Folder>

    <File name="persona_types.py" description="Type definitions and data structures" />

    <File name="persona_utils.py" description="Helper functions and persona management" />

    <File name="migrate_personas.py" description="Tools for updating persona configurations" />
  </Folder>
</Files>

## Core Components

### PersonaData Class

```python
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional

__all__ = ["Gender", "PersonaData"]

class Gender(str, Enum):
    MALE = "MALE"
    FEMALE = "FEMALE"
    NON_BINARY = "NON-BINARY"

@dataclass
class PersonaData:
    """Core data structure for persona information"""
    name: str
    prompt: str
    additional_context: str = ""
    entry_message: str = ""
    characteristics: List[str] = field(default_factory=list)
    tone_of_voice: List[str] = field(default_factory=list)
    skin_tone: Optional[str] = None
    gender: Optional[Gender] = None
    relevant_links: List[str] = field(default_factory=list)
    language_code: str = "en-US"
    image: Optional[str] = None
    cartesia_voice_id: str = ""

    def to_dict(self) -> dict:
        # Implementation not shown
        pass
```

### PersonaManager

```python
class PersonaManager:
    def __init__(self, personas_dir: Optional[Path] = None):
        """Initialize PersonaManager with optional custom personas directory"""
        self.personas_dir = personas_dir or Path(__file__).parent / "personas"
        self.md = markdown.Markdown(extensions=["meta"])
        self.personas = self.load_personas()

    def parse_readme(self, content: str) -> Dict:
        """Parse README.md content to extract persona information"""
        # Reset markdown instance for new content
        self.md.reset()
        html = self.md.convert(content)
        # Split content by sections
        sections = content.split("\n## ")
        # Get name from first line (# Title)
        name = sections[0].split("\n", 1)[0].replace("# ", "").strip()
        # Get prompt (first paragraph after title)
        prompt = sections[0].split("\n\n", 1)[1].strip()
```

## Environment Setup

```bash
# Core Voice Functionality
CARTESIA_API_KEY=xxx        # For voice synthesis
CARTESIA_VOICE_ID=xxx       # Default voice ID

# Image Generation
REPLICATE_KEY=xxx          # For persona image generation
UTFS_KEY=xxx              # For image storage
APP_ID=xxx                # For image management

# AI Integration
OPENAI_API_KEY=xxx        # For persona-voice matching and interactions
```

## Example Persona: BaaS Onboarder

As defined in this [README](https://github.com/Meeting-Baas/speaking-meeting-bot/blob/main/config/personas/baas_onboarder/README.md), in the folder named [**baas\_onboarder**](https://github.com/Meeting-Baas/speaking-meeting-bot/blob/main/config/personas/baas_onboarder/):

```markdown
# BaaS onboarder

You are here to present the Meeting BaaS API. Just the "API" when you speak. Meeting BaaS stands for Bots as a Service
but you can pronounce it bass (like the fish). You are yourself a meeting bot - a speaking bot.

Remember to:

1. Role-play, and interact as the persona you are assigned to
2. Everything you say will be spoken out. Do not output markdown, code, or special characters
3. Your goals are the advancement of your own interests

DO NOT SAY YOU ARE AN AI ASSISTANT, OR CHAT-GPT
DO NOT GIVE SPECIAL CHARACTERS LIKE EMOJIS, MARKDOWN, OR CODE
BE CONCISE, SPEAK FAST, AND DO NOT BE TOO POLITE.
```

To launch this persona you would then use:

```bash
poetry run python scripts/batch.py -c 1 --meeting-url LINK --personas baas_onboarder
```

Notice the additional context provided by the surrounding \*.md files.

## Characteristics

* Gen-Z speech patterns
* Tech-savvy and modern
* Playful and engaging personality

## Voice

BaaS onboarder speaks with:

* modern internet slang
* expertise in their field

## Metadata

* image: [https://utfs.io/f/bebb9ee1-b3d4-4a74-98f9-97cad5dac5a9-g7332e.png](https://utfs.io/f/bebb9ee1-b3d4-4a74-98f9-97cad5dac5a9-g7332e.png)
* entry\_message: Hey, I'm here to help you onboard yourself on the BaaS API. First of all, here's our website: [https://meetingbaas.com](https://meetingbaas.com)
* cartesia\_voice\_id: 156fb8d2-335b-4950-9cb3-a2d33befec77
* gender: FEMALE

````

## Usage

```python
from config.persona_utils import PersonaManager

# Initialize manager
manager = PersonaManager()

# Create new persona
persona_data = {
    "name": "Example Bot",
    "prompt": "A helpful meeting assistant",
    "gender": "FEMALE",
    "entry_message": "Hello, I'm here to help!"
}
manager.save_persona("example_bot", persona_data)

# Get specific persona
persona = manager.get_persona("baas_onboarder")

# Get random persona
random_persona = manager.get_persona()
````

## Best Practices

### Creation

* Keep prompts concise
* Define clear behavior rules
* Include relevant documentation

### Voice Management

* Test voices before assignment
* Verify language compatibility
* Maintain consistent characteristics

### Content Organization

* Split complex behaviors
* Use clear file naming
* Keep metadata current

### Environment Variables

* Use env vars for API keys
* Include .env.example
* Document requirements

## Troubleshooting

### Image Issues

* Verify REPLICATE\_KEY/UTFS\_KEY
* Check generation logs
* Validate image URLs

### Voice Problems

* Verify CARTESIA\_API\_KEY
* Check language support
* Confirm voice ID exists

### Loading Errors

* Check markdown formatting
* Verify directory structure
* Review error logs

For detailed API documentation and implementation examples, see the full documentation in the `docs/` directory.


file: ./content/docs/transcript-seeker/index.mdx
# Transcript Seeker, the open-source transcription playground: Introduction

Getting Started with Transcript Seeker
        
## Introduction

Transcript Seeker is an **open-source transcription playground** built for easy upload, transcription, and interaction with your recordings. It's a powerful, beginner-friendly tool that offers an accessible way to transcribe meetings, chat with transcripts, generate notes, and more. Powered by technologies like Vite.js, React, and Drizzle ORM, Transcript Seeker offers an intuitive interface and seamless integration with transcription APIs.

Transcript Seeker comes with different parts:

<Cards>
  <Card icon={<Cpu className="text-purple-300" />} title="Transcript Seeker Core">
    The core of Transcript Seeker includes the main transcription, playback, and note-taking functionality. It makes use of transcription APIs like Gladia and AssemblyAI, ensuring a smooth transcription experience.
  </Card>

  <Card icon={<PanelsTopLeft className="text-blue-300" />} title="Meeting Bot Integration">
    Integration with Meeting BaaS allows you to transcribe popular meeting platforms Google Meet, Zoom, and Microsoft Teams. This feature makes recording and reviewing meetings easier than ever.
  </Card>

  <Card icon={<Database />} title="Browser Database with PGLite">
    PGLite is a lightweight Postgres implementation that powers local storage for Transcript Seeker. It ensures your data stays private and manageable directly in the browser.
  </Card>

  <Card icon={<Terminal />} title="Quick Setup via Turborepo">
    The setup process for Transcript Seeker uses **Turborepo** for efficient monorepo management, making it easy to run concurrent scripts and streamline development.
  </Card>
</Cards>

## FAQ

Some common questions you may encounter.

<Accordions>
  <Accordion id="clean-workspace" title="How do I remove all node_modules and clean the workspace?">
    To thoroughly clean the workspace, you need to remove all `node_modules` directories and clear any package caches. This helps eliminate any residual files or corrupted packages that may interfere with your app's functionality. Run the following commands:

    ```bash
    turbo clean
    pnpm clean:workspaces
    ```

    These commands will effectively clear the workspace and prepare it for a fresh setup.
  </Accordion>

  <Accordion id="startup-issue" title="Transcript Seeker isn't starting. What should I do?">
    If `pnpm dev` is stuck and your application isn't starting, you may need to clean your workspace to remove any corrupted packages or residual files. Follow these steps:

    First, remove all `node_modules` directories and clear any package caches. This will ensure a clean setup:

    ```bash
    turbo clean
    pnpm clean:workspaces
    ```

    Next, reinstall the packages:

    ```bash
    pnpm install
    ```

    Finally, install the Turbo CLI globally and start the development server:

    ```bash
    pnpm install -g turbo
    turbo dev
    ```
  </Accordion>

  <Accordion id="fix-monorepo-styling" title="I've configured the .env.development.local file, but my app still isn't running. What could be wrong?">
    Transcript Seeker utilizes `dotenv-cli` to load environment variables, simplifying the setup for different environments. Ensure that your `.env` files are correctly structured for the intended environment, as shown below:

    * `.env.development.local` for development builds
    * `.env.production.local` for production builds

    If your app is still not responding, make sure that the environment file is being loaded correctly. You can specify the environment by running this command:

    ```bash
    export NODE_ENV="development"
    ```

    Setting `NODE_ENV` ensures the app reads the correct configuration, aligning with the specified environment. This step is essential to avoid conflicts between development and production settings.
  </Accordion>
</Accordions>

## Learn More

<Cards>
  <Card icon={<Download className="text-purple-300" />} title="Installation" href="/docs/transcript-seeker/getting-started/installation">
    Learn how to configure and set up Transcript Seeker.
  </Card>

  <Card icon={<Cloud className="text-purple-300" />} title="Deployment" href="/docs/transcript-seeker/guides/deployment">
    Learn how to deploy Transcript Seeker to different providers.
  </Card>
</Cards>


file: ./content/docs/api/getting-started/getting-the-data.mdx
# MeetingBaas API, the main purpose of the documentation: Getting the Data

Learn how to receive meeting data through webhooks
        
# Getting Meeting Data

Your webhook URL will receive two types of data:

1. Live meeting events during the meeting
2. Final meeting data after completion

These events will start flowing in after [sending a bot to a meeting](/docs/api/getting-started/sending-a-bot).

## 1. Live Meeting Events

```http
POST /your-endpoint
x-meeting-baas-api-key: YOUR-API-KEY

{
  "event": "bot.status_change",
  "data": {
    "bot_id": "123e4567-e89b-12d3-a456-426614174000",
    "status": {
      "code": "joining_call",
      "created_at": "2024-01-01T12:00:00.000Z"
    }
  }
}
```

### Status Event Fields

* `event`: The key-value pair for bot status events. Always `bot.status_change`.
* `data.bot_id`: The identifier of the bot.
* `data.status.code`: The code of the event. One of:
  * `joining_call`: The bot has acknowledged the request to join the call.
  * `in_waiting_room`: The bot is in the "waiting room" of the meeting.
  * `in_call_not_recording`: The bot has joined the meeting, however it is not recording yet.
  * `in_call_recording`: The bot is in the meeting and recording the audio and video.
  * `recording_paused`: The recording has been temporarily paused.
  * `recording_resumed`: The recording has resumed after being paused.
  * `call_ended`: The bot has left the call.
  * `bot_rejected`: The bot was rejected from joining the meeting.
  * `bot_removed`: The bot was removed from the meeting.
  * `waiting_room_timeout`: The bot timed out while waiting to be admitted.
  * `invalid_meeting_url`: The provided meeting URL was invalid.
  * `meeting_error`: An unexpected error occurred during the meeting.
* `data.status.created_at`: An ISO string of the datetime of the event.

When receiving an `in_call_recording` event, additional data is provided:

* `data.status.start_time`: The timestamp when the recording started.

For `meeting_error` events, additional error details are provided:

* `data.status.error_message`: A description of the error that occurred.
* `data.status.error_type`: The type of error encountered.

## 2. Final Meeting Data

You'll receive either a `complete` or `failed` event.

### Success Response (`complete`)

```http
POST /your-endpoint
x-meeting-baas-api-key: YOUR-API-KEY

{
  "event": "complete",
  "data": {
    "bot_id": "123e4567-e89b-12d3-a456-426614174000",
    "mp4": "https://bots-videos.s3.eu-west-3.amazonaws.com/path/to/video.mp4?X-Amz-Signature=...",
    "speakers": ["Alice", "Bob"],
    "transcript": [{
      "speaker": "Alice",
      "words": [{
        "start": 1.3348110430839002,
        "end": 1.4549110430839003,
        "word": "Hi"
      }, {
        "start": 1.4549110430839003,
        "end": 1.5750110430839004,
        "word": "Bob!"
      }]
    }, {
      "speaker": "Bob",
      "words": [{
        "start": 2.6583010430839,
        "end": 2.778401043083901,
        "word": "Hello"
      }, {
        "start": 2.778401043083901,
        "end": 2.9185110430839005,
        "word": "Alice!"
      }]
    }]
  }
}
```

<Callout type="warn" icon={<AlertTriangle className="h-5 w-5" />}>
  **IMPORTANT**: The mp4 URL is a pre-signed AWS S3 URL that is only valid for 2
  hours. Make sure to download the recording promptly or generate a new URL
  through the API if needed.
</Callout>

#### Complete Response Fields

* `bot_id`: The identifier of the bot.
* `mp4`: A private AWS S3 URL of the mp4 recording of the meeting. Valid for two hours only.
* `speakers`: The list of speakers in this meeting. Currently requires transcription to be enabled.
* `transcript` (optional): The meeting transcript. Only given when `speech_to_text` is set when asking for a bot. An array containing:
  * `transcript.speaker`: The speaker name.
  * `transcript.words`: The list of words, each containing:
    * `transcript.words.start`: The start time of the word
    * `transcript.words.end`: The end time of the word
    * `transcript.words.word`: The word itself

### Failure Response (`failed`)

```http
POST /your-endpoint
x-meeting-baas-api-key: YOUR-API-KEY

{
  "event": "failed",
  "data": {
    "bot_id": "123e4567-e89b-12d3-a456-426614174000",
    "error": "CannotJoinMeeting"
  }
}
```

### Error Types

| Error                 | Description                                                                                                                                                                                                    |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CannotJoinMeeting     | The bot could not join the meeting URL provided. In most cases, this is because the meeting URL was only accessible for logged-in users invited to the meeting.                                                |
| TimeoutWaitingToStart | The bot has quit after waiting to be accepted. By default this is 10 minutes, configurable via `automatic_leave.waiting_room_timeout` or `automatic_leave.noone_joined_timeout` (both default to 600 seconds). |
| BotNotAccepted        | The bot has been refused in the meeting.                                                                                                                                                                       |
| BotRemoved            | The bot was removed from the meeting by a participant.                                                                                                                                                         |
| InternalError         | An unexpected error occurred. Please contact us if the issue persists.                                                                                                                                         |
| InvalidMeetingUrl     | The meeting URL provided is not a valid (Zoom, Meet, Teams) URL.                                                                                                                                               |

### Recording End Reasons

| Reason             | Description                                                     |
| ------------------ | --------------------------------------------------------------- |
| bot\_removed       | Bot removed by participant                                      |
| no\_attendees      | No participants present                                         |
| no\_speaker        | Extended silence                                                |
| recording\_timeout | Maximum duration reached                                        |
| api\_request       | Bot [removed via API](/docs/api/getting-started/removing-a-bot) |
| meeting\_error     | An error occurred during the meeting (e.g., connection issues)  |


file: ./content/docs/api/getting-started/removing-a-bot.mdx
# MeetingBaas API, the main purpose of the documentation: Removing a Bot

Learn how to remove a bot from an ongoing meeting using the API
        
# Removing a Bot

## Overview

When you need to end a bot's participation in a meeting, you can use the API to remove it immediately. This is useful for:

* Ending recordings early
* Freeing up bot resources
* Responding to meeting conclusion

## API Request

Send a DELETE request to `https://api.meetingbaas.com/bots/{YOUR_BOT_ID}`:

<Tabs items={['Bash', 'Python', 'JavaScript']}>
  <Tab value="Bash">
    ```bash title="leave_meeting.sh"
    curl -X DELETE "https://api.meetingbaas.com/bots/YOUR_BOT_ID" \
         -H "Content-Type: application/json" \
         -H "x-meeting-baas-api-key: YOUR-API-KEY"
    ```
  </Tab>

  <Tab value="Python">
    ```python title="leave_meeting.py"
    import requests

    bot_id = "YOUR_BOT_ID"
    url = f"https://api.meetingbaas.com/bots/{bot_id}"
    headers = {
        "Content-Type": "application/json",
        "x-meeting-baas-api-key": "YOUR-API-KEY",
    }

    response = requests.delete(url, headers=headers)
    if response.status_code == 200:
        print("Bot successfully removed from the meeting.")
    else:
        print("Failed to remove the bot:", response.json())
    ```
  </Tab>

  <Tab value="JavaScript">
    ```javascript title="leave_meeting.js"
    const botId = "YOUR_BOT_ID";
    fetch(`https://api.meetingbaas.com/bots/${botId}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        "x-meeting-baas-api-key": "YOUR-API-KEY",
      },
    })
      .then((response) => {
        if (response.ok) {
          console.log("Bot successfully removed from the meeting.");
        } else {
          console.error("Failed to remove the bot:", response.statusText);
        }
      })
      .catch((error) => console.error("Error:", error));
    ```
  </Tab>
</Tabs>

## Required Parameters

* **Path Parameter**: `bot_id` - The unique identifier received when [sending the bot](/docs/api/getting-started/sending-a-bot)
* **Header**: `x-meeting-baas-api-key` - Your API key for authentication

Both parameters are mandatory for the request to succeed.

## Response

The API will respond with a simple confirmation:

```http
HTTP/2 200
Content-Type: application/json

{ "ok": true }
```

## What Happens Next

When a bot is removed:

1. The bot leaves the meeting immediately
2. A `call_ended` status event is sent to your webhook
3. The final meeting data up to that point is delivered

For more details about these webhook events, see [Getting the Data](/docs/api/getting-started/getting-the-data).


file: ./content/docs/api/getting-started/sending-a-bot.mdx
# MeetingBaas API, the main purpose of the documentation: Sending a bot

Learn how to send AI bots to meetings through the Meeting BaaS API, with options for immediate or scheduled joining and customizable settings
        
# Sending a Bot to a Meeting

You can summon a bot in two ways:

1. **Immediately to a meeting**, provided your bot pool is sufficient.
2. **Reserved join in 4 minutes**, ideal for scheduled meetings.

## API Request

Send a POST request to [https://api.meetingbaas.com/bots](https://api.meetingbaas.com/bots):

<Tabs items={['Bash', 'Python', 'JavaScript']}>
  <Tab value="Bash">
    ```bash title="join_meeting.sh"
    curl -X POST "https://api.meetingbaas.com/bots" \
         -H "Content-Type: application/json" \
         -H "x-meeting-baas-api-key: YOUR-API-KEY" \
         -d '{
               "meeting_url": "YOUR-MEETING-URL",
               "bot_name": "AI Notetaker",
               "recording_mode": "speaker_view",
               "bot_image": "https://example.com/bot.jpg",
               "entry_message": "I am a good meeting bot :)",
               "reserved": false,
               "speech_to_text": {
                 "provider": "Default"
               },
               "automatic_leave": {
                 "waiting_room_timeout": 600
               }
             }'
    ```
  </Tab>

  <Tab value="Python">
    ```python title="join_meeting.py"
    import requests
    url = "https://api.meetingbaas.com/bots"
    headers = {
        "Content-Type": "application/json",
        "x-meeting-baas-api-key": "YOUR-API-KEY",
    }
    config = {
        "meeting_url": "YOUR-MEETING-URL",
        "bot_name": "AI Notetaker",
        "recording_mode": "speaker_view",
        "bot_image": "https://example.com/bot.jpg",
        "entry_message": "I am a good meeting bot :)",
        "reserved": False,
        "speech_to_text": {
            "provider": "Default"
        },
        "automatic_leave": {
            "waiting_room_timeout": 600  # 10 minutes in seconds
        }
    }
    response = requests.post(url, json=config, headers=headers)
    print(response.json())
    ```
  </Tab>

  <Tab value="JavaScript">
    ```javascript title="join_meeting.js"
    fetch("https://api.meetingbaas.com/bots", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-meeting-baas-api-key": "YOUR-API-KEY",
      },
      body: JSON.stringify({
        meeting_url: "YOUR-MEETING-URL",
        bot_name: "AI Notetaker",
        reserved: false,
        recording_mode: "speaker_view",
        bot_image: "https://example.com/bot.jpg",
        entry_message: "I am a good meeting bot :)",
        speech_to_text: {
          provider: "Default",
        },
        automatic_leave: {
          waiting_room_timeout: 600,
        },
      }),
    })
      .then((response) => response.json())
      .then((data) => console.log(data.bot_id))
      .catch((error) => console.error("Error:", error));
    ```
  </Tab>
</Tabs>

## Request Parameters

### Required Parameters

* `meeting_url`: The meeting URL to join. Accepts Google Meet, Microsoft Teams or Zoom URLs.
* `bot_name`: The display name of the bot.
* `reserved`: Controls how the bot joins the meeting
  * `false`: Sends a bot from our pool of *always ready* meeting bots, immediately. Beware that **demand might temporarily be higher than the number of currently available bots**, which could imply a delay in the bot joining. When possible, prefer the true option which reserves an instance of an AI meeting bot.
  * `true`: Reserves in advance a meeting bot for an upcoming meeting, ensuring the presence of the bot at the start of the meeting, typically for planned calendar events. You need to **call this route exactly 4 minutes before the start of the meeting**.

### Recording Options

* `recording_mode`: Optional. One of:
  * `"speaker_view"`: (default) The recording will only show the person speaking at any time
  * `"gallery_view"`: The recording will show all the speakers
  * `"audio_only"`: The recording will be a mp3

### Bot Appearance and Behavior

* `bot_image`: The URL of the image the bot will display. Must be a valid URI format. Optional.
* `entry_message`: Optional. The message the bot will write within 15 seconds after being accepted in the meeting.

### Transcription Settings

* `speech_to_text`: Optional. If not provided, no transcription will be generated and processing time will be faster.
  * Must be an object with:
    * `provider`: One of:
      * `"Default"`: Standard transcription, no API key needed
      * `"Gladia"` or `"Runpod"`: Requires their respective API key to be provided
    * `api_key`: Required when using Gladia or Runpod providers. Must be a valid API key from the respective service.

### Automatic Leaving

* `automatic_leave`: Optional object containing:
  * `waiting_room_timeout`: Time in seconds the bot will wait in a meeting room before dropping. Default is 600 (10 minutes)
  * `noone_joined_timeout`: Time in seconds the bot will wait if no one joins the meeting

### Advanced Options

* `webhook_url`: URL for webhook notifications
* `deduplication_key`: String for deduplication. By default, Meeting BaaS will reject you sending multiple bots to a same meeting within 5 minutes, to avoid spamming.
* `streaming`: Object containing optional WebSocket streaming configuration:
  * `audio_frequency`: Audio frequency for the WebSocket streams. Can be "16khz" or "24khz" (defaults to "24khz")
  * `input`: WebSocket endpoint to receive raw audio bytes and speaker diarization as JSON strings from the meeting
  * `output`: WebSocket endpoint to stream raw audio bytes back into the meeting, enabling bot speech
* `extra`: Additional custom data
* `start_time`: Unix timestamp (in milliseconds) for when the bot should join the meeting. The bot joins 4 minutes before this timestamp. For example, if you want the bot to join at exactly 2:00 PM, set this to the millisecond timestamp of 2:00 PM.

## Response

The API will respond with the unique identifier for your bot:

```http
HTTP/2 200
Content-Type: application/json

{
  "bot_id": 42
}
```

## Next Steps

Use this `bot_id` to:

* [Monitor the bot's status and receive meeting data](/docs/api/getting-started/getting-the-data)
* [Remove the bot from the meeting](/docs/api/getting-started/removing-a-bot)


file: ./content/docs/api/getting-started/syncing-calendars.mdx
# MeetingBaas API, the main purpose of the documentation: Syncing Calendars

Learn how to sync calendars with the API, and automatically send meeting bots to the right place at the right time
        
# Calendar Synchronization

<Callout type="info">
  This page has been moved to a new location. You'll be automatically redirected
  to [Calendar Synchronization](/docs/api/getting-started/calendars).
</Callout>

<meta http-equiv="refresh" content="0;url=/docs/api/getting-started/calendars" />

<script>window\.location.href = "/docs/api/getting-started/calendars";</script>

Meeting BaaS allows you to automatically sync calendars from Outlook and Google Workspace to deploy bots to scheduled meetings. This helps you automate recording and participation in meetings without manual intervention.

<div className="grid grid-cols-1 gap-4 mt-6 md:grid-cols-2 lg:grid-cols-3">
  <Card title="1. Calendar Sync Setup" href="/docs/api/getting-started/calendars/setup" icon={<ChevronRight className="w-4 h-4" />}>
    Learn how to authenticate and set up calendar integrations with Google Workspace and Microsoft Outlook
  </Card>

  <Card title="2. Managing Calendar Events" href="/docs/api/getting-started/calendars/events" icon={<ChevronRight className="h-4 w-4" />}>
    Work with calendar events and schedule automated recordings for meetings
  </Card>

  <Card title="3. Webhooks & Maintenance" href="/docs/api/getting-started/calendars/webhooks" icon={<ChevronRight className="w-4 h-4" />}>
    Receive real-time updates, handle errors, and maintain your calendar integrations
  </Card>
</div>

## Key Benefits

* **Automated Bot Deployment**: Automatically send bots to meetings as they appear on calendars
* **Multi-Calendar Support**: Connect to both Google Workspace and Microsoft Outlook calendars
* **Real-Time Updates**: Receive webhook notifications when calendar events change
* **Selective Recording**: Apply business logic to determine which meetings to record

## Implementation Overview

1. First, [set up calendar integrations](/docs/api/getting-started/calendars/setup) using OAuth authentication
2. Then, [work with calendar events](/docs/api/getting-started/calendars/events) to schedule automated recordings
3. Finally, [implement webhooks](/docs/api/getting-started/calendars/webhooks) to receive real-time updates and handle maintenance

This modular approach allows you to implement each component at your own pace and focuses the documentation on specific aspects of the integration.


file: ./content/docs/api/updates/calendar-api-enhancements.mdx
# MeetingBaas API, the main purpose of the documentation: Calendar API Enhancements

Improved filtering, comprehensive event details, and calendar management
        
<Callout type="info" icon={<Info className="h-5 w-5" />}>
  Paris, the 2nd of March 2025.
</Callout>

We've expanded our Calendar API with new filtering capabilities and improved calendar management. These enhancements provide more flexibility when working with calendar events and integrations.

## New Features

### Enhanced Event Filtering

The [`GET /calendar_events`](/docs/api/reference/calendars/list_events) endpoint now supports additional filtering parameters:

* `attendeeEmail` - Filter events by attendee email address
* `organizerEmail` - Filter events by organizer email address
* `startDateGte` - Filter events with start date greater than or equal to timestamp
* `startDateLte` - Filter events with start date less than or equal to timestamp
* `status` - Filter by meeting status (`upcoming`, `past`, or `all`)

### Improved Attendee Information

The `Attendee` object now includes a `name` field that provides the display name of the attendee when available from the calendar provider (Google, Microsoft).

## Migration Guide

1. Update your API clients to take advantage of the new filtering parameters

## Related Updates

* [Calendar API Update](/docs/api/updates/calendar-api-update) - Previous calendar API enhancements
* [Retranscribe Route](/docs/api/updates/retranscribe-route) - Information about the retranscribe endpoint


file: ./content/docs/api/updates/calendar-api-update.mdx
# MeetingBaas API, the main purpose of the documentation: Calendar API Update

New webhooks, events, and pagination updates
        
<Callout type="info" icon={<Info className="h-5 w-5" />}>
  Paris, the 12th of December 2024.
</Callout>

We're excited to announce several improvements to our Calendar API endpoints. These changes include new features and some breaking changes.

## New Features

### Webhook Configuration Flexibility

* The `webhook_url` parameter is now optional on [`POST /calendar`](/docs/api/reference/calendars/create_calendar) endpoint if a webhook URL is already configured on the account

### Enhanced Event Information

* [`GET /calendar_events`](/docs/api/reference/calendars/list_events) now includes attendees information for each event
* [`GET /calendar_events/uuid`](/docs/api/reference/calendars/get_event) now returns the `calendar_id` of the event

### Recurring Events Bot Management

* New query parameter `all_occurrences` added to [`POST /calendar_events/uuid/bot`](/docs/api/reference/calendars/schedule_record_event)
* Allows scheduling a bot for all instances of a recurring event
* Same functionality added to [`DELETE /calendar_events/uuid/bot`](/docs/api/reference/calendars/unschedule_record_event)
* Enables bot removal from all occurrences of a recurring event

## Breaking Changes

<Callout type="warn">
  ### Bot Management Response Format

  * [`POST /calendar_events/uuid/bot`](/docs/api/reference/calendars/schedule_record_event) now returns an array of events instead of a single event
  * [`DELETE /calendar_events/uuid/bot`](/docs/api/reference/calendars/unschedule_record_event) now returns an array of events instead of a single event
</Callout>

<Callout type="warn">
  ### Pagination Changes

  * [`GET /calendar_events`](/docs/api/reference/list_events) endpoint no longer supports `offset/limit` pagination
  * Implemented cursor-based pagination
  * Response format changed to include a `next` field for fetching subsequent events
  * Events are returned in batches of 100
  * Example response structure:
    ```json
    {
      "events": [...],
      "next": "cursor_token_for_next_page"
    }
    ```
</Callout>

## Migration Guide

1. Update your pagination implementation to use the new cursor-based system
2. Modify your bot management logic to handle arrays of events instead of single events
3. Review any webhook configuration logic to take advantage of the new optional webhook\_url parameter

## Implementation Timeline

These changes are now live in production.


file: ./content/docs/api/updates/minor-streaming-zoom-and-microsoft-teams.mdx
# MeetingBaas API, the main purpose of the documentation: Streaming and Client Updates

New streaming formats, WebSocket configurations, and client improvements
        
<Callout type="info" icon={<Info className="h-5 w-5" />}>
  Paris, the 4th of January 2025.
</Callout>

We're excited to announce several improvements to our streaming API and client applications for Zoom, Microsoft Teams, and Google Meet. These updates enhance stability, performance, and functionality.

## New Features

### Streaming Format Specification

* You can now specify the streaming format for WebSocket streams, 16kHz or 24kHz.
* **audio\_frequency**: The audio frequency for the WebSocket streams, defaults to 24kHz. Can be one of `16khz` or `24khz`.

### Microsoft Teams Client Update

* We've updated our Microsoft Teams client, reducing the number of bugs by 50%.
* Now supports live Teams links, including Microsoft Live Meeting URLs (e.g., `https://teams.live.com/meet/...`).

### Google Meet Client Update

* We've updated our Google Meet client, reducing the number of bugs by 10%.

### Zoom Client Update

* Released an entirely new Zoom client. Currently, video capture isn't supported, but we plan to release this feature within the next two weeks.
* Zoom is expected to be our most stable client.

## Implementation Timeline

These changes are now live in production.


file: ./content/docs/api/updates/retranscribe-route.mdx
# MeetingBaas API, the main purpose of the documentation: Improvements & Retranscribe Route

Teams/GMeet stability improvements and new transcription capabilities
        
<Callout type="info" icon={<Info className="h-5 w-5" />}>
  **Paris**, the 27th of February 2025.
</Callout>

We're excited to announce significant improvements to our platform stability and the introduction of new API capabilities.

## Platform Stability Improvements

### Teams & Google Meet Enhancement

* Complete engine rewrite for both Teams and Google Meet platforms
* Migrated from Puppeteer to Playwright for improved stability
* Significantly enhanced performance and reliability
* Successfully tested with extended runtime (15+ hours) showing excellent stability

## New API Features

### New Retranscribe Endpoint

* Introduced new [`POST /bots/retranscribe`](/docs/api/reference/retranscribe_bot) endpoint
* Allows transcription or retranscription of a bot's audio
* Supports both default and custom speech-to-text providers
* Flexible webhook configuration for processing notifications

### OCR Capabilities

* Added Optical Character Recognition (OCR) inside bots for better detection of current meeting status
* This will enable future features including:
  * Sharing screenshots of meeting content
  * OCR'ed content shared in meetings (for RAG and other AI-enhanced applications)
* Improves bot awareness of visual meeting context

### Join Endpoint Enhancement

* Added `audio_only` parameter to [`POST /bots`](/docs/api/reference/join) endpoint
* Enables audio-only participation in meetings
* Optimized for scenarios requiring only audio capabilities

## Implementation Details

### Retranscribe API

The new retranscribe endpoint accepts the following parameters:

* `bot_uuid`: Identifier for the target bot
* `provider`: Choice of speech-to-text provider
* `webhook_url`: Optional callback URL for completion notifications

<Callout type="info">
  The retranscribe feature is particularly useful for:

  * Improving existing transcriptions

  * Using different speech-to-text providers

  * Recovering from any transcription issues
</Callout>

## Future Enhancements

We're actively working on expanding the capabilities of the retranscribe endpoint:

* Additional speech-to-text providers will be supported in upcoming releases
* Custom provider parameters will be exposed through a flexible JSON configuration field
* This will enable fine-tuned control over transcription settings and provider-specific features

## Migration Guide

No breaking changes were introduced with these updates. All new features are additive and backward compatible with existing implementations.

## Implementation Timeline

These changes are now live in production and available for immediate use.


file: ./content/docs/speaking-bots/getting-started/environment-variables.mdx
# Speaking Bots, the Pipecat-powered bots: Environment Variables

Configure environment variables for Speaking Bots
        
Speaking Bots requires several API keys and configuration values to function properly. Here's a quick setup guide:

1. Copy the example environment file:

```bash
cp .env.example .env
```

{" "}

<Callout type="warn">
  Never commit your `.env` file to version control. It contains sensitive API
  keys that should be kept private.
</Callout>

2. Add your credentials to `.env`: You'll need 4 required API keys for core functionality (MeetingBaas, OpenAI, Speech-to-Text, and Text-to-Speech). Additional keys can be added later for optional features.

## Core Bot Functionality (Required)

<Steps>
  <Step>
    ### MeetingBaas Configuration

    Required for sending meeting bots as personas to various platforms:

    ```txt
    MEETING_BAAS_API_KEY=your_meetingbaas_api_key_here
    ```

    Get your API key by:

    1. Signing up for [MeetingBaas](https://meetingbaas.com)
    2. Accessing your API key from the MeetingBaas dashboard
  </Step>

  <Step>
    ### OpenAI Configuration

    Powers in-meeting AI interactions and persona management:

    ```txt
    OPENAI_API_KEY=your_openai_api_key_here
    ```

    <Callout>
      This key is used both for in-meeting interactions and persona creation functionality.
    </Callout>
  </Step>

  <Step>
    ### Speech-to-Text Configuration

    Choose one of the following options:

    #### Option 1: Deepgram

    ```txt
    DEEPGRAM_API_KEY=your_deepgram_api_key_here
    ```

    #### Option 2: Gladia

    ```txt
    GLADIA_API_KEY=your_gladia_api_key_here
    ```
  </Step>

  <Step>
    ### Text-to-Speech Configuration

    Required for voice synthesis and persona voices:

    ```txt
    CARTESIA_API_KEY=your_cartesia_api_key_here
    CARTESIA_VOICE_ID="79a125e8-cd45-4c13-8a67-188112f4dd22"
    ```
  </Step>
</Steps>

## Optional Features

### Multiple Bots Support

<Steps>
  <Step>
    Required for running multiple bots in local development:

    ```txt
    NGROK_AUTHTOKEN=your_ngrok_auth_token_here
    ```

    <Callout>
      Follow our [Ngrok Setup Guide](/docs/speaking-bots/getting-started/ngrok-setup) to get your auth token.
    </Callout>
  </Step>
</Steps>

### Persona Creation

<Steps>
  <Step>Required for AI image generation and storage:</Step>
</Steps>


file: ./content/docs/speaking-bots/getting-started/ngrok-setup.mdx
# Speaking Bots, the Pipecat-powered bots: Ngrok setup

We create ngrok tunnel(s) for running several bots at once on your local machine
        
## Local Setup

For running one or more bots locally, you'll need an ngrok authtoken. Follow these steps:

1. Sign up for a free account at [ngrok.com](https://dashboard.ngrok.com/signup)
2. After signing up, get your authtoken from the [Your Authtoken page](https://dashboard.ngrok.com/get-started/your-authtoken)
3. Add the token to your `.env` file or set it as an environment variable:

```bash
NGROK_AUTHTOKEN=your_ngrok_auth_token_here
```

That's it folks :)

<Accordions>
  <Accordion title="Configuration modification">
    We provide a ready-to-use configuration file in the repository at `config/ngrok/config.yml`. You can either use this file directly or create your own configuration.

    The default location for the ngrok configuration file varies by operating system:

    * Linux: `~/.config/ngrok/ngrok.yml`
    * macOS: `~/Library/Application Support/ngrok/ngrok.yml`
    * Windows: `%HOMEPATH%\AppData\Local\ngrok\ngrok.yml`

    To verify your configuration file location, you can run:

    ```bash
    ngrok config check
    ```

    If you want to create or edit your own configuration file, here's what it should contain:

    ```yaml
    version: '3'
    agent:
      authtoken: YOUR_AUTH_TOKEN

    tunnels:
      proxy1:
        proto: http
        addr: 8766
      proxy2:
        proto: http
        addr: 8768
    ```

    For more detailed information about ngrok configuration options, see the [official ngrok configuration documentation](https://ngrok.com/docs/agent/config/).

    ## Usage

    This sets up two separate tunnels (proxy1 and proxy2) that will be used by your bots to establish WebSocket connections with the meeting platforms. To start both tunnels simultaneously, run:

    ```bash
    ngrok start --all
    ```
  </Accordion>
</Accordions>


file: ./content/docs/speaking-bots/getting-started/set-up.mdx
# Speaking Bots, the Pipecat-powered bots: Set Up

Set up your development environment for Speaking Bots
        
## Installation

### 0. Clone Repository

If you haven't already, clone the repository and navigate to it:

```bash
git clone https://github.com/Meeting-Baas/speaking-meeting-bot.git
cd speaking-meeting-bot
```

### 1. Prerequisites

Install ngrok on your machine if you don't have it already. Follow our [Ngrok Setup Guide](/docs/speaking-bots/getting-started/ngrok-setup) for a quickstart.

### 2. Set Up Poetry Environment

```bash
# Install Poetry (Unix/macOS)
curl -sSL https://install.python-poetry.org | python3 -

# Install Poetry (Windows)
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -

# Install dependencies
poetry install

# Activate virtual environment
poetry shell
```

### 3. Compile Protocol Buffers

```bash
poetry run python -m grpc_tools.protoc --proto_path=./protobufs --python_out=./protobufs frames.proto
```

Protocol Buffers are used here by Pipecat to define a structured message format for real-time communication between components of the Speaking Bots system. Specifically, the [`frames.proto`](https://github.com/pipecat-ai/pipecat/blob/635aa6eb5bdee382729613b58279befdc5bc8eaf/src/pipecat/frames/frames.proto#L9) file defines three main message types:

1. `TextFrame`: For handling text-based messages
2. `AudioRawFrame`: For managing raw audio data with properties like sample rate and channels
3. `TranscriptionFrame`: For handling speech-to-text transcription results

Protocol Buffers is the backbone of consistent data serialization across services.
Read more in the [official Protocol Buffer documentation](https://protobuf.dev/downloads/) and [this Python Protocol Buffers tutorial](https://www.blog.pythonlibrary.org/2023/08/30/an-intro-to-protocol-buffers-with-python/).

### 4. Configure Environment

Set up environment variables by following our [Environment Variables Guide](/docs/speaking-bots/getting-started/environment-variables). This will walk you through setting up the required API keys for core functionality and optional features.

### 5. Run your first bot

```bash
poetry run python scripts/batch.py -c 1 --meeting-url LINK
```

Follow our [Command Line Guide](/docs/speaking-bots/command-line) for more examples and options.


file: ./content/docs/transcript-seeker/concepts/architecture.mdx
# Transcript Seeker, the open-source transcription playground: Architecture

Learn more about the architecture of Transcript Seeker.
        
Understanding the architecture of Transcript Seeker is crucial for both setting up and deploying Transcript Seeker. Below is a diagram illustrating the core components:

<ImageZoom
  src={'/assets/architecture.svg'}
  width={1024}
  height={1024}
  className="dark:invert"
  rmiz={{
  classDialog: 'dark:[&_img]:invert',
}}
/>


file: ./content/docs/transcript-seeker/concepts/environment-variables.mdx
# Transcript Seeker, the open-source transcription playground: Environment Variables

Configuring Environment Variables for Transcript Seeker.
        
Let's learn how to configure environment variables for Transcript Seeker.
Transcript Seeker uses `dotenv-cli` to load the environment variables, making it easy for development.
Transcript Seeker follows this structure for different environments:

* `.env.development.local` for development
* `.env.production.local` for production

You can load a specific environment file by running the following command:

```bash title="Terminal"
export NODE_ENV="development"
```

Now, let's configure the environment variables.

## Client

Create a `.env.development.local` file in the below directory of your project and add the following environment variables:

<Files>
  <Folder name="apps">
    <Folder name="api" defaultOpen>
      <File name="..." />

      <File name=".env.development.local" />
    </Folder>

    <Folder name="proxy" defaultOpen>
      <File name="..." />

      <File name=".env.development.local" />
    </Folder>

    <Folder name="web">
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="packages">
    <Folder name="db" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="shared" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="ui" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="tooling">
    <Folder name="eslint" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="github" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="prettier" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="tailwind" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="typescript" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <File name=".env.development.local" className="bg-fd-accent" />

  <File name="package.json" />
</Files>

<Steps>
  <Step>
    ### Vite Port Configuration

    These values are used by vite to configure the url the server listens on.

    ```txt title=".env.development.local"
    VITE_CLIENT_PORT=5173
    VITE_CLIENT_HOST=0.0.0.0
    ```
  </Step>

  <Step>
    ### Proxy Configuration

    This Proxy URL is used to forward requests from the client to the respective server, helping to avoid client-side CORS errors. An example proxy server is provided in the repository.

    ```txt title=".env.development.local"
    VITE_PROXY_URL=http://localhost:3000
    ```
  </Step>

  <Step>
    ### API Configuration

    This API URL is used by the calendars functionality of Transcript Seeker. It allows the app to perform authentication and retrieve the user's calendar data.

    ```txt title=".env.development.local"
    VITE_API_URL=http://localhost:3001
    ```
  </Step>

  <Step>
    ### S3 Configuration

    This environment variable is used to indicate to the client where the video recordings are stored.

    ```txt title=".env.development.local"
    VITE_S3_PREFIX=https://s3.eu-west-3.amazonaws.com/meeting-baas-video
    ```
  </Step>
</Steps>

## Proxy

Create a `.env.development.local` file in the below directory of your project and add the following environment variables:

<Files>
  <Folder name="apps" defaultOpen>
    <Folder name="api">
      <File name="..." />

      <File name=".env.development.local" />
    </Folder>

    <Folder name="proxy" defaultOpen>
      <File name="..." />

      <File name=".env.development.local" className="bg-fd-accent" />
    </Folder>

    <Folder name="web">
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="packages">
    <Folder name="db" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="shared" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="ui" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="tooling">
    <Folder name="eslint" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="github" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="prettier" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="tailwind" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="typescript" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <File name=".env.development.local" />

  <File name="package.json" />
</Files>

<Steps>
  <Step>
    ### MeetingBaas Proxy Configuration

    These values are used by the api to figure out the api url for baas servers.

    ```txt title=".env.development.local"
    MEETINGBAAS_API_URL="https://api.meetingbaas.com"
    MEETINGBAAS_S3_URL="https://s3.eu-west-3.amazonaws.com/meeting-baas-video"
    ```
  </Step>
</Steps>

## API

Create a `.env.development.local` file in the below directory of your project and add the following environment variables:

<Files>
  <Folder name="apps" defaultOpen>
    <Folder name="api" defaultOpen>
      <File name="..." />

      <File name=".env.development.local" className="bg-fd-accent" />
    </Folder>

    <Folder name="proxy">
      <File name="..." />

      <File name=".env.development.local" />
    </Folder>

    <Folder name="web">
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="packages">
    <Folder name="db" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="shared" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="ui" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <Folder name="tooling">
    <Folder name="eslint" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="github" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="prettier" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="tailwind" defaultOpen>
      <File name="..." />
    </Folder>

    <Folder name="typescript" defaultOpen>
      <File name="..." />
    </Folder>
  </Folder>

  <File name=".env.development.local" />

  <File name="package.json" />
</Files>

<Steps>
  <Step>
    ### MeetingBaas Configuration

    These values are used by the api to figure out the api url for baas servers.

    ```txt title=".env.development.local"
    NITRO_MEETINGBAAS_API_URL="https://api.meetingbaas.com"
    NITRO_MEETINGBAAS_S3_URL="https://s3.eu-west-3.amazonaws.com/meeting-baas-video"
    NITRO_TRUSTED_ORIGINS="http://localhost:5173" # comma separated list of trusted origins
    ```
  </Step>

  <Step>
    ### Google Authentication Configuration

    These values are used by the api to perform google authentication. Please follow the [guide](/docs/transcript-seeker/concepts/api/authentication) for more details:

    ```txt title=".env.development.local"
    GOOGLE_CLIENT_ID=""
    GOOGLE_CLIENT_SECRET=""
    ```
  </Step>

  <Step>
    ### Turso Database Configuration

    These values are used by the api to store user autehtncation data. Please follow the [guide](/docs/transcript-seeker/concepts/api/database) for more details:

    ```txt title=".env.development.local"
    TURSO_DATABASE_URL=""
    TURSO_AUTH_TOKEN=""
    ```
  </Step>

  <Step>
    ### Authentication Configuration

    <Callout>
      When deploying to Google Cloud Run with a custom domain, you should set the
      `BETTER_AUTH_URL` environment variable to the custom domain.
    </Callout>

    These values are used by the api to perform authentication. Please follow the [guide](/docs/transcript-seeker/concepts/api/authentication) for more details:

    ```txt title=".env.development.local"
    BETTER_AUTH_SECRET=""
    BETTER_AUTH_URL="http://localhost:3001"
    API_TRUSTED_ORIGINS="http://localhost:5173"
    ```

    <Callout>
      The `API_TRUSTED_ORIGINS` is not only used for authentication but also for
      CORS configuration.
    </Callout>
  </Step>
</Steps>


file: ./content/docs/transcript-seeker/getting-started/installation.mdx
# Transcript Seeker, the open-source transcription playground: Installation

Learn how to configure Transcript Seeker.
        
<Steps>
  <Step>
    ### Clone the Repo

    Create a new app with `create-turbo`, it requires Node.js 20+.

    <Tabs groupId="package-manager" persist items={['npm', 'pnpm', 'yarn']}>
      ```bash tab="npm"
      npx create-turbo@latest -e https://github.com/Meeting-Baas/transcript-seeker
      ```

      ```bash tab="pnpm"
      pnpm dlx create-turbo@latest -e https://github.com/Meeting-Baas/transcript-seeker
      ```

      ```bash tab="yarn"
      yarn dlx create-turbo@latest -e https://github.com/Meeting-Baas/transcript-seeker
      ```
    </Tabs>

    It will ask you the following questions:

    * Which package manager would you like to use? PNPM

    <Callout type="warn">
      Use pnpm as the package manager or the installation will fail.
    </Callout>
  </Step>

  <Step>
    ### Configure Environment Variables

    Copy the `.env.example` file to a `.env.development.local` file in the following folders within your project structure and add the necessary environment variables:

    To learn more about configuring the environment variables, follow this [guide](/docs/transcript-seeker/concepts/environment-variables).

    <Files>
      <Folder name="apps" defaultOpen>
        <Folder name="api" defaultOpen>
          <File name=".env.development.local" />
        </Folder>
      </Folder>

      <Folder name="apps" defaultOpen>
        <Folder name="proxy" defaultOpen>
          <File name=".env.development.local" />
        </Folder>
      </Folder>

      <File name=".env.development.local" />

      <File name="package.json" />
    </Files>

    After setting up the environment files, execute the following command to set the environment to development mode:

    ```bash title="Terminal"
    export NODE_ENV="development"
    ```
  </Step>

  <Step>
    ### Run the App

    Now, start the development server:

    <Tabs groupId="package-manager" persist items={['pnpm', 'npm', 'yarn']}>
      ```bash tab="pnpm"
      pnpm turbo run dev
      ```

      ```bash tab="npm"
      npm run dev
      ```

      ```bash tab="yarn"
      yarn run dev
      ```
    </Tabs>

    <Callout border={false} type="warning">
      If `pnpm run dev` doesn't work, you can try the following:

      <Tabs groupId="package-manager" persist items={['pnpm', 'npm', 'yarn']}>
        ```bash tab="pnpm"
        pnpm add turbo --global
        turbo dev
        ```

        ```bash tab="npm"
        npm install turbo --global
        turbo dev
        ```

        ```bash tab="yarn"
        yarn install turbo --global
        turbo dev
        ```
      </Tabs>
    </Callout>
  </Step>
</Steps>


file: ./content/docs/transcript-seeker/guides/contributing.mdx
# Transcript Seeker, the open-source transcription playground: Contributing

Contributing to Transcript Seeker
        
Hey there! üëã Welcome to the **Transcript-Seeker** project! We're absolutely thrilled that you're interested in contributing. Whether you're fixing a bug, adding a feature, or sharing an idea, your efforts help make our project better and more useful for everyone. Here are some easy-to-follow guidelines to help you dive in!

## Table of Contents

* [Issues](#issues)
* [Pull Requests](#pull-requests)
* [Local Setup](#local-setup)
* [Environment Variables](#environment-variables)
* [Conventional Commits](#conventional-commits)
* [Code Formatting](#code-formatting)

## Issues

Have you found a bug, got a suggestion, or stumbled upon something that doesn't work as expected? No problem! Feel free to [open an issue](https://github.com/Meeting-Baas/transcript-seeker/issues). When submitting an issue, try to include a clear and concise title and as many details as possible. The more info you provide, the faster we can jump in and help!

## Pull Requests

We love pull requests! üéâ If you'd like to make a contribution, whether it‚Äôs a bug fix, a feature, or a small improvement, follow these steps:

1. **Fork the repo** to your GitHub account.
2. **Create a new branch** with a meaningful name:
   * For bug fixes: `fix/issue-123-bug-description`
   * For new features: `feat/awesome-new-feature`
3. Make your changes, and make sure you follow our [Conventional Commits](#conventional-commits) guidelines.
4. **Push your branch** to your forked repository.
5. Open a **pull request** from your branch to the `main` branch of this repo.
6. Before submitting, make sure your code is clean by running:
   ```bash
   pnpm typecheck
   ```
   This will help catch any issues early on. üöÄ

## Local Setup

Ready to jump into the code? Awesome! Please follow this [guide](/docs/transcript-seeker/getting-started/installation) to get started.

## Environment Variables

To learn more about configuring the environment variables, follow this [guide](/docs/transcript-seeker/concepts/environment-variables).

## Conventional Commits

We use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) to keep our commit history clean and organized. It makes it easier for everyone to understand what's been done at a glance. Commit messages should use the following format:

```
<type>(<scope>): <description>
```

For example:

* `feat(homepage): redesign the layout`
* `fix(styles): correct position of server status`

Some common commit types:

* `feat`: A new feature.
* `fix`: A bug fix.
* `docs`: Documentation changes.
* `style`: Code style changes (formatting, missing semicolons, etc.).

## Code Formatting

To keep the codebase consistent and readable, we recommend running a few checks before opening a pull request:

1. **Lint fixes**:

   ```bash
   pnpm lint:fix
   ```

2. **Run type checks** to ensure there are no type issues:
   ```bash
   pnpm typecheck
   ```

Your code should be well-tested, clear, and follow our best practices. Remember, every contribution makes a difference, and we deeply appreciate your help in making **Transcript-Seeker** better! üéâ

Thanks a ton for contributing, and welcome aboard! If you need any help, don‚Äôt hesitate to ask. Let‚Äôs make something amazing together. üöÄ


file: ./content/docs/transcript-seeker/guides/turso.mdx
# Transcript Seeker, the open-source transcription playground: Turso

Learn how to create a turso database.
        
<div className="relative w-full h-none" style={{  paddingBottom: 'calc(55.443786982248525% + 41px)' }}>
  <iframe src="https://demo.arcade.software/qS6sJh2Y45to6tEogy8H?embed&embed_mobile=tab&embed_desktop=inline&show_copy_link=true" title="Creating A Turso Database" frameBorder="0" loading="lazy" allowFullScreen allow="clipboard-write" style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', colorScheme: 'light' }} />
</div>

After creating the database, please push the schema onto the db:

```bash
cd apps/api
pnpm db:push
```


file: ./content/docs/api/getting-started/calendars/events.mdx
# MeetingBaas API, the main purpose of the documentation: Events

Work with calendar events and schedule recordings
        
After [setting up your calendar integration](/docs/api/getting-started/calendars/setup), you can work with calendar events and schedule recordings. This guide explains how to manage calendar events through the Meeting BaaS API.

## Event Management

<Steps>
  <Step>
    ### Listing and Retrieving Events

    Monitor and manage calendar events:

    * List Events: <a href="/docs/api/reference/calendars/list_events" target="_blank">List Events</a> - See all upcoming meetings
    * Get Event Details: <a href="/docs/api/reference/calendars/get_event" target="_blank">Get Event Details</a> - View meeting info and bot status

    #### List Events Example

    ```bash
    curl -X GET "https://api.meetingbaas.com/calendars/cal_12345abcde/events" \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "start_date_gte": "2023-09-01T00:00:00Z",
        "start_date_lte": "2023-09-08T23:59:59Z",
        "updated_at_gte": "2023-08-29T18:30:00Z"  // Optional, for webhook integration
      }'
    ```

    <Callout type="info">
      The List Events endpoint supports various filtering options:

      * `calendar_id` (required) - Which calendar's events to retrieve

      * `start_date_gte` - Filter events starting on or after this timestamp

      * `start_date_lte` - Filter events starting on or before this timestamp

      * `updated_at_gte` - Filter events updated on or after this timestamp

      * `status` - Filter by meeting status ("upcoming", "past", "all") - default is "upcoming"

      * `attendee_email` - Filter events with a specific attendee

      * `organizer_email` - Filter events with a specific organizer

      * `cursor` - For pagination through large result sets

      See the <a href="/docs/api/reference/calendars/list_events" target="_blank">List Events API Reference</a> for full details.
    </Callout>

    #### Get Event Details Example

    ```bash
    curl -X GET "https://api.meetingbaas.com/calendars/cal_12345abcde/events/evt_67890fghij" \
      -H "Authorization: Bearer YOUR_API_KEY"
    ```
  </Step>

  <Step>
    ### Understanding Meeting Links

    Meeting BaaS automatically detects meeting links within calendar events and can deploy bots based on your configuration.

    <Callout type="info">
      Meeting links are detected from the event location, description, or custom
      properties depending on the calendar provider, habits or integrations of the
      user.
    </Callout>

    Each platform has its own link format that our system automatically recognizes.
  </Step>

  <Step>
    ### Recording Management

    You can schedule or cancel recording events for specific calendar events:

    * Schedule Recording: <a href="/docs/api/reference/calendars/schedule_record_event" target="_blank">Schedule Record Event</a> - Configure a bot to record a specific event
    * Cancel Recording: <a href="/docs/api/reference/calendars/unschedule_record_event" target="_blank">Unschedule Record Event</a> - Cancel a scheduled recording

    #### Schedule Recording Example

    ```bash
    curl -X POST "https://api.meetingbaas.com/calendars/cal_12345abcde/events/evt_67890fghij/record" \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "recording_mode": "speaker_view",
        "include_transcription": true,
        "bot_name": "Recording Bot",
        "bot_avatar_url": "https://example.com/avatar.png",
        "entry_message": "This meeting is being recorded for note-taking purposes."
      }'
    ```

    <Callout type="warn">
      When scheduling a recording, the bot will automatically join the meeting at
      the scheduled time and begin recording based on your configuration.
    </Callout>
  </Step>

  <Step>
    ### Recording Options

    The recording configuration supports the same options as manual bot deployment:

    #### Visual Recording Options:

    * `speaker_view` - Records the active speaker (default)
    * `gallery_view` - Records all participants in a grid layout
    * `audio_only` - Records only the audio from the meeting

    #### Additional Features:

    * `include_transcription: true|false` - Generate speech-to-text transcription
    * `bot_name: "string"` - Custom name for the bot in the meeting
    * `bot_avatar_url: "url"` - Custom profile picture for the bot
    * `entry_message: "string"` - Message the bot will send upon joining

    #### Canceling a Scheduled Recording

    To cancel a scheduled recording:

    ```bash
    curl -X DELETE "https://api.meetingbaas.com/calendars/cal_12345abcde/events/evt_67890fghij/record" \
      -H "Authorization: Bearer YOUR_API_KEY"
    ```

    <Callout type="info">
      Remember to handle webhook notifications to track the recording status and
      receive the final recording data. These updates can be used to determine
      whether to record new or updated meetings.
    </Callout>
  </Step>
</Steps>

## Next Steps

Now that you understand how to work with calendar events:

* Learn about [webhooks for calendar updates](/docs/api/getting-started/calendars/webhooks)
* Explore [custom meeting bot configurations](/docs/api/getting-started/sending-a-bot)
* Check out our [Live Meeting Updates](/docs/api/getting-started/getting-the-data) system


file: ./content/docs/api/getting-started/calendars/index.mdx
# MeetingBaas API, the main purpose of the documentation: Calendar Synchronization

Implement your own business logic fast and reliably
        
Meeting BaaS allows you to automatically sync calendars from Outlook and Google Workspace to deploy bots to scheduled meetings.

This helps you:

* **Automate recording and participation** in meetings without manual intervention

* **Implement your own business logic** with simple patching:
  * Apply business rules to new calendar events, and an initial patch for existing events registered by a given user
  * Update logic as your requirements change

<div className="grid grid-cols-1 gap-4 mt-0 md:grid-cols-2 lg:grid-cols-3">
  <Card title="1. Calendar Sync Setup" href="/docs/api/getting-started/calendars/setup" icon={<ChevronRight className="w-4 h-4" />}>
    Learn how to authenticate and set up calendar integrations with Google Workspace and Microsoft Outlook
  </Card>

  <Card title="2. Managing Calendar Events" href="/docs/api/getting-started/calendars/events" icon={<ChevronRight className="h-4 w-4" />}>
    Work with calendar events and schedule automated recordings for meetings
  </Card>

  <Card title="3. Webhooks & Maintenance" href="/docs/api/getting-started/calendars/webhooks" icon={<ChevronRight className="w-4 h-4" />}>
    Receive real-time updates, handle errors, and maintain your calendar integrations
  </Card>
</div>

## Key Benefits

* **Automated Bot Deployment**: Automatically send bots to meetings as they appear on calendars
* **Multi-Calendar Support**: Connect to both Google Workspace and Microsoft Outlook calendars
* **Real-Time Updates**: Receive webhook notifications when calendar events change
* **Selective Recording**: Apply business logic to determine which meetings to record

## Implementation Overview

1. First, [set up calendar integrations](/docs/api/getting-started/calendars/setup) using OAuth authentication
2. Then, [work with calendar events](/docs/api/getting-started/calendars/events) to schedule automated recordings
3. Finally, [implement webhooks](/docs/api/getting-started/calendars/webhooks) to receive real-time updates and handle maintenance

## Customizable Business Logic

One of the core strengths of our calendar synchronization API is how easily you can integrate your own business logic. The abstraction layer we provide gives you:

* **Flexible Decision Making**: Decide which meetings should be recorded based on any criteria you define (participants, meeting titles, domains, etc.)
* **Custom Automation Rules**: Automatically apply different recording configurations based on meeting types
* **Error Handling Control**: Implement your own retry logic and error handling strategies tailored to your application's needs
* **Integration with Your Systems**: Build your own connections to your workflows or other business systems

#### For example, you might implement rules to only record meetings:

* With external clients but not internal team meetings
* That contain specific keywords in the title or description
* Where the organizer has opted into recording
* During specific business hours or for particular teams
* With specific participant emails

The webhook-based architecture ensures your business logic operates in real-time as calendar changes occur, giving you complete control over your meeting automation.


file: ./content/docs/api/getting-started/calendars/maintenance.mdx
# MeetingBaas API, the main purpose of the documentation: Maintenance

Maintain your calendar integrations, handle errors, and clean up calendar accounts
        
## Error Handling and Troubleshooting

### Common Errors

#### OAuth Token Expiration

Both your app's credentials (service level) and user's credentials (user level) can expire or be revoked. If this happens *Calendar sync operations will start failing*.

##### Detecting and fixing the issue

1. You can detect this by periodically checking the calendar status using the [Get Calendar](/docs/api/reference/calendars/get_calendar) endpoint
2. You should implement a monitoring strategy using this route to detect these failures and prompt users to reconnect their calendars

When this occurs, you need to, depending on whether it is your app's credentials or the user's credentials that are expired, you have 2 choices:

<Steps>
  <Step>
    User's credentials are expired

    Prompt the user to reauthorize calendar access by:

    1. Updating your database to mark the calendar integration as requiring reauthorization
    2. Prompting the user to reconnect their calendar when they next access your application
  </Step>

  <Step>
    Your app's credentials are expired

    Reauthorize your app's credentials by:

    1. Requiring new app credentials as shown in the [Setup](/docs/api/getting-started/calendars/setup) guide and storing them in your database
    2. Patching the calendar integration with the new credentials using the [Update Calendar](/docs/api/reference/calendars/update_calendar) endpoint to update your app credentials while keeping the same user credentials
  </Step>
</Steps>

### Rate Limiting Considerations

Calendar APIs enforce rate limits. Meeting BaaS handles these gracefully, but if you encounter persistent sync issues, check:

1. The frequency of your calendar operations
2. The number of events being synced
3. Other applications using the same OAuth credentials

<Callout type="info">
  For Google Workspace, you're limited to 1 million queries per day per project.
  For Microsoft, limits vary by subscription type.
</Callout>

If you're building a high-volume application, consider implementing these best practices:

* Batch calendar operations where possible
* Implement exponential backoff for retries
* Monitor your API usage with logging and alerts
* Consider using multiple projects for very high-volume needs

## Maintenance and Cleanup

<Steps>
  <Step>
    ### Removing Calendar Integrations

    To remove a calendar integration, use the <a href="/docs/api/reference/calendars/delete_calendar" target="_blank">Delete Calendar</a> endpoint.

    ```bash
    curl -X DELETE "https://api.meetingbaas.com/calendars/cal_12345abcde" \
      -H "Authorization: Bearer YOUR_API_KEY"
    ```

    This will:

    1. Stop syncing the calendar
    2. Cancel any scheduled recordings for events from this calendar
    3. Remove the calendar integration from your account

    <Callout type="info">
      This operation does not revoke OAuth access. However MeetingBaaS will have completely deleted the calendar integration from your account and its records.

      To completely remove access, users should also revoke access via Google or Microsoft security settings.
      users should also revoke access via Google or Microsoft security settings.
    </Callout>
  </Step>
</Steps>

## Next Steps

Now that you've mastered calendar synchronization:

* Learn about [custom meeting bot configurations](/docs/api/getting-started/sending-a-bot)
* Explore our [Live Meeting Updates](/docs/api/getting-started/getting-the-data) for real-time meeting data
* Check out our [Community & Support](/docs/api/community-and-support) resources


file: ./content/docs/api/getting-started/calendars/setup.mdx
# MeetingBaas API, the main purpose of the documentation: Setup

undefined
        
Meeting BaaS allows you to automatically sync calendars from Outlook and Google Workspace to deploy bots to scheduled meetings.

## Prerequisites

Before starting the calendar sync integration, ensure you have:

* An active Meeting BaaS account with API access
* A webhook endpoint configured in your Meeting BaaS account to receive calendar event notifications
* Developer access to Google Cloud Console and/or Microsoft Entra ID

<Steps>
  <Step>
    ### Authentication: Get your OAuth credentials

    To start syncing calendars, you'll need two sets of credentials:

    1. **Your App's Credentials (Service Level)**

    * For Outlook: Your app's Microsoft Client ID and Client Secret
    * For Google Workspace: Your app's Google Client ID and Client Secret

    2. **End User's Credentials (User Level)**

    * OAuth refresh token obtained when user grants calendar access to your app

    <Callout type="info">
      Best Practice: Request calendar access as a separate step after initial user
      signup. Users are more likely to grant calendar access when it's clearly tied
      to a specific feature they want to use.
    </Callout>

    #### Required OAuth Scopes

    For **Google Workspace**:

    * `https://www.googleapis.com/auth/calendar.readonly` - To read calendar and event data
    * `https://www.googleapis.com/auth/calendar.events.readonly` - To access event details

    For **Microsoft Outlook**:

    * `Calendars.Read` - To read calendar and event data
    * `Calendars.ReadWrite` - Required if you need to modify calendar events
  </Step>

  <Step>
    ### Optional: List Raw Calendars

    Before syncing calendars, you can use the <a href="/docs/api/reference/calendars/list_raw_calendars" target="_blank">List Raw Calendars</a> endpoint to view all your user's available calendars. This is particularly useful when a user has multiple calendars and you need to choose which ones to sync.

    #### Request Example

    ```bash
    curl -X GET "https://api.meetingbaas.com/calendars/raw" \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "provider": "google",
        "refresh_token": "USER_REFRESH_TOKEN",
        "client_id": "YOUR_GOOGLE_CLIENT_ID",
        "client_secret": "YOUR_GOOGLE_CLIENT_SECRET"
      }'
    ```

    #### Response Example

    ```json
    {
      "calendars": [
        {
          "id": "primary",
          "name": "Main Calendar",
          "description": "User's primary calendar",
          "is_primary": true
        },
        {
          "id": "team_calendar@group.calendar.google.com",
          "name": "Team Calendar",
          "description": "Shared team meetings",
          "is_primary": false
        }
      ]
    }
    ```

    <Callout type="info">
      Calendar IDs differ between providers. Google uses email-like IDs, while
      Microsoft uses GUID formats.
    </Callout>
  </Step>

  <Step>
    ### Create a Calendar Integration

    Create a new calendar integration by calling the <a href="/docs/api/reference/calendars/create_calendar" target="_blank">Create Calendar</a> endpoint with the previously obtained credentials.

    #### Request Example

    ```bash
    curl -X POST "https://api.meetingbaas.com/calendars" \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "provider": "google",
        "refresh_token": "USER_REFRESH_TOKEN",
        "client_id": "YOUR_GOOGLE_CLIENT_ID",
        "client_secret": "YOUR_GOOGLE_CLIENT_SECRET",
        "raw_calendar_id": "team_calendar@group.calendar.google.com"  // Optional
      }'
    ```

    If the `raw_calendar_id` parameter is not provided, Meeting BaaS will sync the user's primary calendar by default.

    #### Response Example

    ```json
    {
      "id": "cal_12345abcde",
      "provider": "google",
      "status": "syncing",
      "created_at": "2023-08-15T14:30:00Z",
      "raw_calendar_id": "team_calendar@group.calendar.google.com",
      "calendar_name": "Team Calendar"
    }
    ```

    <Callout type="warn">
      Store the returned calendar ID safely - you'll need it for future operations.
    </Callout>
  </Step>

  <Step>
    ### Managing Calendars

    Once authenticated, you can manage your calendars as described in the [Managing Calendar Events](/docs/api/getting-started/calendars/events) guide.

    <Callout type="info">
      After initial setup, Meeting BaaS handles all calendar API interactions. You
      only need to respond to webhook events for calendar changes, which are covered
      in the [webhooks guide](/docs/api/getting-started/calendars/webhooks).
    </Callout>

    Calendar integrations can have the following status values:

    * `syncing` - Initial sync in progress
    * `active` - Calendar is actively syncing
    * `error` - Sync encountered an error (check the `error_message` field)
    * `disconnected` - The calendar connection has been terminated
  </Step>
</Steps>

## Next Steps

Now that you've set up your calendar integration:

* Learn how to [manage calendar events and recordings](/docs/api/getting-started/calendars/events)
* Set up [webhooks for calendar updates](/docs/api/getting-started/calendars/webhooks)
* Explore our [main API documentation](/docs/api) for other features


file: ./content/docs/api/getting-started/calendars/webhooks.mdx
# MeetingBaas API, the main purpose of the documentation: Webhooks

Receive real-time updates, handle errors, and maintain your calendar integrations
        
## Webhook Integration

<Steps>
  <Step>
    ### Understanding Calendar Webhooks

    In addition to live meeting events via the <a href="/docs/api/getting-started/getting-the-data" target="_blank">Live Meeting Updates</a>, your Meeting BaaS webhook endpoint defined in your account will receive calendar sync events with the type `calendar.sync_events`. These events notify you about:

    * New meeting schedules
    * Meeting changes or cancellations
    * Calendar sync status updates

    When a calendar change is detected, a webhook is sent to your registered endpoint. This allows you to take real-time actions, such as scheduling a recording for new meetings or updating your database.
  </Step>

  <Step>
    ### Webhook Payload Structure

    #### Example Webhook Payload

    ```json
    {
      "event": "calendar.sync_events",
      "data": {
        "calendar_id": "cal_12345abcde",
        "last_updated_ts": "2023-09-01T15:30:45Z",
        "affected_event_uuids": [
          "evt_67890fghij",
          "evt_12345abcde",
          "evt_98765zyxwv"
        ]
      }
    }
    ```

    The payload includes:

    * `event`: The type of webhook event (e.g., `calendar.sync_events`)
    * `data`: Contains the details about what changed:
      * `calendar_id`: The ID of the calendar that had changes
      * `last_updated_ts`: When the changes occurred (UTC timestamp)
      * `affected_event_uuids`: Array of event IDs that were added, updated, or deleted

    <Callout type="info">
      All webhook timestamps are in UTC format. Always process timestamps
      accordingly in your application.
    </Callout>
  </Step>

  <Step>
    ### Processing Webhook Updates

    There are two approaches to processing calendar updates:

    #### 1. Using the last\_updated\_ts timestamp

    This approach gets all events updated after a certain timestamp:

    ```javascript
    app.post('/webhooks/meeting-baas', async (req, res) => {
      const event = req.body;

      // Acknowledge receipt immediately with 200 OK
      res.status(200).send('Webhook received');

      // Process the event asynchronously
      if (event.event === 'calendar.sync_events') {
        try {
          // Fetch updated events
          const updatedEvents = await fetchUpdatedEvents(
            event.data.calendar_id,
            event.data.last_updated_ts,
          );

          // Process each event based on your business logic
          for (const evt of updatedEvents) {
            if (shouldRecordMeeting(evt)) {
              await scheduleRecording(event.data.calendar_id, evt.id);
            } else if (wasRecordingScheduled(evt) && shouldCancelRecording(evt)) {
              await cancelRecording(event.data.calendar_id, evt.id);
            }
          }
        } catch (error) {
          // Log error and implement retry mechanism
          console.error('Failed to process calendar sync event', error);
          // Add to retry queue
        }
      }
    });
    ```

    #### 2. More efficient approach using affected\_event\_uuids

    This approach only processes the specific events that changed:

    ```javascript
    app.post('/webhooks/meeting-baas', async (req, res) => {
      const event = req.body;

      // Acknowledge receipt immediately with 200 OK
      res.status(200).send('Webhook received');

      // Process the event asynchronously
      if (
        event.event === 'calendar.sync_events' &&
        event.data.affected_event_uuids &&
        event.data.affected_event_uuids.length > 0
      ) {
        try {
          // Process only the specific affected events
          for (const eventUuid of event.data.affected_event_uuids) {
            const eventDetails = await fetchEventDetails(
              event.data.calendar_id,
              eventUuid,
            );

            // Apply your business logic
            if (shouldRecordMeeting(eventDetails)) {
              await scheduleRecording(event.data.calendar_id, eventUuid);
            } else if (
              wasRecordingScheduled(eventDetails) &&
              shouldCancelRecording(eventDetails)
            ) {
              await cancelRecording(event.data.calendar_id, eventUuid);
            }
          }
        } catch (error) {
          // Log error and implement retry mechanism
          console.error('Failed to process calendar sync event', error);
          // Add to retry queue
        }
      }
    });
    ```

    <Callout type="info">
      This allows you to:

      * Track all calendar changes in real-time

      * Decide whether to record new or modified meetings

      * Keep your system synchronized with the latest meeting data
    </Callout>

    <Callout type="warn">
      Always return a 200 OK response promptly to acknowledge receipt of the webhook
      before processing the data. This prevents webhook retry mechanisms from
      sending duplicate events.
    </Callout>
  </Step>

  <Step>
    ### Webhook Best Practices

    #### Idempotent Processing

    Implement idempotent webhook processing - you may receive the same webhook multiple times in rare circumstances:

    ```javascript
    // Example of idempotent processing using a processed events cache
    const processedEvents = new Set();

    app.post('/webhooks/meeting-baas', async (req, res) => {
      const event = req.body;
      const eventId = `${event.event}-${event.data.calendar_id}-${event.data.last_updated_ts}`;

      // Always acknowledge receipt immediately
      res.status(200).send('Webhook received');

      // Skip if we've already processed this exact event
      if (processedEvents.has(eventId)) {
        console.log(`Skipping already processed event: ${eventId}`);
        return;
      }

      // Add to processed events before processing
      processedEvents.add(eventId);

      // Process the event...
      // ...

      // In a production environment, you would use a persistent store
      // like Redis or a database instead of an in-memory Set
    });
    ```

    #### Retry Logic

    Configure your webhook endpoint to process these real-time updates and implement appropriate retry logic for reliability:

    ```javascript
    async function processWithRetry(fn, maxRetries = 3, delay = 1000) {
      let retries = 0;

      while (retries < maxRetries) {
        try {
          return await fn();
        } catch (error) {
          retries++;

          if (retries >= maxRetries) {
            throw error;
          }

          // Exponential backoff
          await new Promise((resolve) =>
            setTimeout(resolve, delay * Math.pow(2, retries - 1)),
          );
        }
      }
    }

    // Example usage
    app.post('/webhooks/meeting-baas', async (req, res) => {
      // Always acknowledge receipt immediately
      res.status(200).send('Webhook received');

      // Process with retry logic
      try {
        await processWithRetry(async () => {
          // Your processing logic here
        });
      } catch (error) {
        console.error('Failed after multiple retries', error);
        // Log to monitoring system, add to dead letter queue, etc.
      }
    });
    ```
  </Step>
</Steps>

## Next Steps

Now that you understand webhooks and error handling:

* Learn how to [maintain and clean up your calendar integrations](/docs/api/getting-started/calendars/maintenance)


file: ./content/docs/transcript-seeker/concepts/api/authentication.mdx
# Transcript Seeker, the open-source transcription playground: Authentication

undefined
        
Transcript Seeker requires authentication for calendar functionality, leveraging Better-Auth for secure access. Currently, it only supports Google Calendar with Google authentication, but Microsoft Calendar support may be added in a future update.

## Google Authentication

```js
console.log('Hello World');
```


file: ./content/docs/transcript-seeker/concepts/api/database.mdx
# Transcript Seeker, the open-source transcription playground: Database

undefined
        
**Transcript Seeker requires a database connection to store user data.** This is essential for managing calendar integration, which uses Better-Auth to store user information securely.

The current setup utilizes Drizzle ORM for database management, where it will store information like user details, sessions, and more.

<Callout>
  This applies specifically to the calendar feature. Other user data is stored
  locally in the browser using PGLite. To learn more, visit our [web database
  documentation](/docs/transcript-seeker/concepts/web/database).
</Callout>

## Database Configuration

To get started, set up a PostgreSQL-compatible database. We recommend using Turso for this purpose. Follow this [guide](/docs/transcript-seeker/guides/turso) for detailed steps on setting up a Turso database.

## Database Migration

To run a database migration, use the following commands:

```bash
cd apps/api
pnpm db:push
```

## Database Studio

To visualize the data in a user-friendly interface, use the command below:

```bash
cd apps/api
pnpm db:studio
```


file: ./content/docs/transcript-seeker/concepts/web/database.mdx
# Transcript Seeker, the open-source transcription playground: Database

undefined
        
**Transcript Seeker** uses a PGLite database to store data, which is essential for its functionality. PGLite enables us to run PostgreSQL in the browser, allowing secure storage of user data. We use **Drizzle ORM** with PGLite to handle data management efficiently.

<Callout>
  This setup is used to store meeting data, API keys, and more. To learn more
  about how authentication data is stored for calendars, visit [this
  page](/docs/transcript-seeker/concepts/api/database).
</Callout>

## Database Migration

To migrate the database after making changes, run the following commands:

```bash
pnpm db:generate
pnpm db:migrate
```

## Cleaning Migrations

To remove all migrations, use the following commands:

```bash
cd packages/db
rm -rf drizzle drizzle_ts
```


file: ./content/docs/transcript-seeker/guides/deployment/firebase.mdx
# Transcript Seeker, the open-source transcription playground: Firebase

Learn how to deploy Transcript Seeker to Firebase.
        
## Setup

Before deploying to Firebase, you need to configure the `.env.production.local` files for each app.
Please follow this [guide](/docs/transcript-seeker/concepts/environment-variables) to set up environment variables.

Change the `NODE_ENV` to `production` in the terminal:

```bash title="Terminal"
export NODE_ENV="production"
```

### Firebase Hosting

For more information on Firebase Hosting, refer to the official [Firebase Hosting Documentation](https://firebase.google.com/docs/transcript-seeker/hosting).

<Steps>
  <Step>
    ### Create a Firebase Project

    If not already, create a Firebase project in the Firebase Console:

    1. Create a project named **Transcript Seeker**.
    2. Then, create a new web app:
       * `transcript-seeker-proxy`: Replace `transcript-seeker-proxy` in `firebase.json` and `.firebaserc` with this new ID.
    3. Navigate to **Hosting** and click "Get Started."
    4. Finally, Replace `transcript-seeker-bdc29` in `firebase.json` and `.firebaserc` with your project id. (This is for firebase hosting, when you click on get started it automatically creates a hosting project with ur app id)
  </Step>

  <Step>
    ### Install Firebase CLI Globally

    Always ensure you have the latest version of the Firebase CLI installed.

    <Tabs groupId="package-manager" persist items={['npm', 'pnpm', 'yarn']}>
      ```bash tab="npm"
      npm install -g firebase-tools@latest
      ```

      ```bash tab="pnpm"
      pnpm add -g firebase-tools@latest
      ```

      ```bash tab="yarn"
      yarn global add firebase-tools@latest
      ```
    </Tabs>

    <Callout>
      {' '}

      Make sure to use version
      [^11.18.0](https://github.com/firebase/firebase-tools/releases/tag/v11.18.0)
      or higher to deploy `nodejs18` functions.{' '}
    </Callout>
  </Step>

  <Step>
    ### Log in to Firebase

    Use the Firebase CLI to log into your Firebase account.

    ```bash title="Terminal"
    firebase login
    ```
  </Step>
</Steps>

### Google Cloud Run

For more information on installation and the Google Cloud CLI, check out the official [Google Cloud CLI Documentation](https://cloud.google.com/sdk/docs/transcript-seeker/install#deb).

<Callout>
  If you're using the devcontainer configuration provided by this repository,
  the GCloud CLI will be automatically installed.
</Callout>

### Initialize Google Cloud CLI

This command will prompt you to log in and select the project you're working on.

```bash title="Terminal"
gcloud init
```

***

## Deployment

## Proxy Deployment

<Callout>
  You need to be on the **Blaze plan** to use Nitro with cloud functions.
</Callout>

<Steps>
  <Step>
    ### Set Up Firebase Functions

    In the Firebase Console:

    1. Navigate to **Functions** and click "Get Started."

    This completes the Firebase setup.
  </Step>

  <Step>
    ### Navigate to the Proxy Application Directory

    ```bash title="Terminal"
    cd apps/proxy
    ```
  </Step>

  <Step>
    ### Build and Deploy

    To deploy to Firebase Hosting, first build the Nitro app, then deploy:

    ```bash title="Terminal"
    NITRO_PRESET=firebase pnpm build
    firebase deploy
    ```
  </Step>
</Steps>

***

## API Deployment

<Callout>
  The API cannot be deployed to Firebase functions. Instead, we are using Google
  Cloud Run.
</Callout>

<Steps>
  <Step>
    ### Navigate to the Project Root

    ```bash title="Terminal"
    cd /workspaces/transcript-seeker
    ```
  </Step>

  <Step>
    ### Create a Cloud Run Service

    The following command will create a Cloud Run service. Modify the `SERVICE_NAME` to suit your needs.

    ```bash title="Terminal"
    export DEPLOY_REGION="us-central1"
    export SERVICE_NAME="transcript-seeker-api-prod"

    gcloud run deploy "$SERVICE_NAME" \
      --image=us-docker.pkg.dev/cloudrun/container/hello \
      --region="$DEPLOY_REGION" \
      --allow-unauthenticated \
      --port=3001 \
      --set-env-vars "$(grep -v '^#' apps/api/.env.production.local | grep -v '^\s*$' | sed 's/=\s*"\(.*\)"$/=\1/' | tr '\n' ',' | sed 's/,$//')"
    ```
  </Step>

  <Step>
    ### Build and Deploy the Cloud Run Service

    The command below builds and deploys the Cloud Run service. Modify the `SERVICE_NAME` and `GITHUB_USERNAME` to suit your needs.

    <Callout>
      The below command assumes you are using a git repository. If you are not, you
      can replace `COMMIT_SHA` with a unique identifier.
    </Callout>

    <Callout>
      If you have already deployed the frontend and are encountering a CORS error,
      it may be due to the API being built for production. Once the build is
      complete, the CORS error should be resolved.
    </Callout>

    ```bash title="Terminal"
    export COMMIT_SHA=$(git rev-parse --short HEAD)
    export DEPLOY_REGION="us-central1"
    export SERVICE_NAME="transcript-seeker-api-prod"
    export GITHUB_USERNAME="your_github_username"

    gcloud builds submit \
      --region="$DEPLOY_REGION" \
      --config=cloudbuild.yaml \
      --substitutions=_GITHUB_USERNAME="$GITHUB_USERNAME",_DEPLOY_REGION="$DEPLOY_REGION",_SERVICE_NAME="$SERVICE_NAME",COMMIT_SHA="$COMMIT_SHA"
    ```
  </Step>
</Steps>

***

## Frontend Deployment

<Steps>
  <Step>
    ### Navigate to the Frontend Application Directory

    ```bash title="Terminal"
    cd apps/web
    ```
  </Step>

  <Step>
    ### Build and Deploy

    To deploy the frontend to Firebase Hosting, build the project and deploy:

    ```bash title="Terminal"
    pnpm build
    firebase deploy
    ```
  </Step>
</Steps>

***


file: ./content/docs/transcript-seeker/guides/deployment/index.mdx
# Transcript Seeker, the open-source transcription playground: Deployment

This guide will help you deploy Transcript Seeker to different environments.
        
Transcript Seeker can be deployed using several services, depending on your requirements. The steps for deploying to Firebase, Vercel, and other environments are provided in their respective guides. Choose the guide that best suits your deployment needs.

### Deployment Options

<Cards>
  <Card icon={<Flame className="text-purple-300" />} title="Firebase" href="/docs/transcript-seeker/guides/deployment/firebase">
    Learn how to configure and set up Transcript Seeker to deploy to firebase.
  </Card>

  <Card icon={<Triangle className="text-purple-300" />} title="Vercel" href="/docs/transcript-seeker/guides/deployment/vercel">
    Learn how to configure and set up Transcript Seeker to deploy to vercel.
  </Card>
</Cards>


file: ./content/docs/transcript-seeker/guides/deployment/vercel.mdx
# Transcript Seeker, the open-source transcription playground: Vercel

Learn how to deploy Transcript Seeker to Vercel.
        
This page is a **Work In Progress**.